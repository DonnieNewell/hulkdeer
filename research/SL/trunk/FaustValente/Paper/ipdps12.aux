\relax 
\citation{li}
\citation{CUDA1,CUDA2}
\citation{OpenMP}
\citation{MPI-2.2}
\citation{meng}
\@writefile{toc}{\contentsline {section}{\numberline {I}Introduction}{1}}
\citation{li}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces SL System Diagram showing information flow in SL. The SL source is combined by the SL compiler with the appropriate optimized back-end template. The resultant generated subroutine for the ISL calculation is called by the rest of the user's application code.\vspace  {-.20in}}}{2}}
\newlabel{fig:SysOrg}{{1}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {II}SL System Organization}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {III}Iterative Stencil Loops: Terms \& Background}{2}}
\citation{meng}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces (a) For a single tile in a 2D matrix, the number of valid calculated values decreases with each additional time interval between synchronization events. After 4 time steps, only the inner most rectangle of $n$ values are valid. (b) Two adjacent tiles shown from the plane of the 2D array with time in the vertical dimension. In the first time step (bottom) there is substantial overlap in the ghost zones in order to have the resultant valid values abut after 4 time steps (top).\vspace  {-.20in}}}{3}}
\newlabel{fig:trapezoid}{{2}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces The {\tt  hotspot.sl} stencil language file. This example shows a 2D stencil calculation where each cell value is based on the values of that cell's immediate neighbors. The read-only data is interpreted as a 2D matrix in row-major order which indicates that some areas of the chip inherently run hotter then other areas.\vspace  {-.20in}}}{3}}
\newlabel{fig:hotspot}{{3}{3}}
\@writefile{toc}{\contentsline {section}{\numberline {IV}Stencil Language Description}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {IV-A}}Syntax}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {IV-B}}Content}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {IV-C}}Read Only Data}{4}}
\@writefile{toc}{\contentsline {section}{\numberline {V}Stencil Language Compiler}{4}}
\citation{CUDA1,CUDA2}
\citation{Fermi}
\@writefile{toc}{\contentsline {section}{\numberline {VI}Generated CUDA Code}{5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {VI-A}}CUDA Architecture Overview}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces NVIDIA GPU Diagram. The CPU control thread launches a kernel with many threads per thread block. Each thread block is assigned to a Multiprocessor (PE) containing 8 scalar processing elements and a local shared memory. The Device Memory is global to all thread blocks; in pre-Fermi GPUs it was uncached.\vspace  {-.20in}}}{5}}
\newlabel{fig:CUDAOrg}{{4}{5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {VI-B}}SL CUDA Template}{5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {VI-C}}Pyramid Height Calculation}{6}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {\unhbox \voidb@x \hbox {VI-C}1}Modification of Meng and Skadron Model}{6}}
\citation{Mashey}
\@writefile{toc}{\contentsline {section}{\numberline {VII}Experimental Results}{7}}
\newlabel{sec:results}{{VII}{7}}
\citation{hotspot}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Fermi runtimes for the Pathfinder 1D application versus PH. The lowest portion of the curves are very flat. Therefore, even though our model did not pick the optimal PH for any data set size, performance was still near optimal.\vspace  {-.20in}}}{8}}
\newlabel{fig:pathfinderTimes}{{5}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {VII-A}}\em  ``Pathfinder''}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Fermi runtimes for the HotSpot 2D stencil application versus PH. As can be seen, the curve is bowl shape with a minimum at PH 2. The effect is more pronounced with greater data set sizes. Our optimizer picked the correct PH of 2 for all these data sets.\vspace  {-.20in}}}{8}}
\newlabel{fig:hotspotTimes}{{6}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {VII-B}}\em  ``HotSpot''}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {VII-C}}\em  ``Plate''}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Fermi runtimes for the Cell 3D stencil application versus PH. The curve shows that a PH of 3 or 4 is a very bad choice. While the values for 1 and 2 are slightly compressed in the graph, the optimal PH is in fact 1 for all data sets.\vspace  {-.20in}}}{9}}
\newlabel{fig:cellTimes}{{7}{9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {VII-D}}\em  ``Cell''}{9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {VII-E}}Model Comparisons}{9}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Fermi runtimes for HotSpot versus normalized runtimes predicted by the Model for PHs from 1 to 6. While the shape of the model curve does not precisely match that of the measured runtimes, the model accurately predicts an optimal PH of two.\vspace  {-.20in}}}{9}}
\newlabel{fig:modelvsactual}{{8}{9}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Runtimes for the SL optimized code for the four applications in Section\nobreakspace  {}VII\hbox {}, plus two new versions of Plate. Runtimes are also shown for a na\"{i}ve CUDA implementation, along with a comparison relative to SL optimized code. For applications with large amounts of either temporal or spatial locality, the SL generated code far outperforms the na\"{i}ve code. For other applications, the difference is more modest. Data are listed for Fermi, on the top of the table, and Tesla, on the bottom. Fermi's larger block size results in higher optimal PH for Plate, PlateHalo, and Plate++ due to the larger tile sizes. The inclusion of a cache on Fermi also results in a lower relative improvement of SL optimized code versus na\"{i}ve for applications with large amounts of temporal or spatial locality.\vspace  {-.20in}}}{10}}
\newlabel{fig:table}{{9}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {VII-F}}Comparison to Na\"{i}ve CUDA code}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {VII-G}}Multinode CUDA with MPI}{10}}
\citation{li}
\citation{cm2}
\citation{DBLP:conf/spaa/TangCKLL11}
\citation{10.1109/IPDPS.2011.70}
\citation{ypnos}
\citation{kamil}
\citation{AutoTuning}
\citation{5470421}
\citation{Micikevicius}
\citation{volkov}
\citation{openmp2gpu}
\citation{Bassetti:1998:OTS:646894.709707}
\citation{Nguyen:2010:BOS:1884643.1884658}
\citation{cudalite}
\citation{Ryoo}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces 2-node performance for Plate at $1000\times 1000$ using a GTX 460 and a C2050. The speedup for the C2050 over the GTX 460 is also included to give a sense of the performance differences of the parts. \vspace  {-.20in}}}{11}}
\newlabel{fig:2-node}{{10}{11}}
\@writefile{toc}{\contentsline {section}{\numberline {VIII}Related Work}{11}}
\@writefile{toc}{\contentsline {section}{\numberline {IX}Conclusions and Future Directions}{11}}
\bibstyle{IEEEtran}
\bibdata{PPoPP-report}
\bibcite{li}{1}
\bibcite{CUDA1}{2}
\bibcite{CUDA2}{3}
\bibcite{OpenMP}{4}
\bibcite{MPI-2.2}{5}
\bibcite{meng}{6}
\bibcite{Fermi}{7}
\bibcite{Mashey}{8}
\bibcite{hotspot}{9}
\bibcite{cm2}{10}
\bibcite{DBLP:conf/spaa/TangCKLL11}{11}
\bibcite{10.1109/IPDPS.2011.70}{12}
\bibcite{ypnos}{13}
\bibcite{kamil}{14}
\bibcite{AutoTuning}{15}
\bibcite{5470421}{16}
\bibcite{Micikevicius}{17}
\bibcite{volkov}{18}
\bibcite{openmp2gpu}{19}
\bibcite{Bassetti:1998:OTS:646894.709707}{20}
\bibcite{Nguyen:2010:BOS:1884643.1884658}{21}
\bibcite{cudalite}{22}
\bibcite{Ryoo}{23}
\@writefile{toc}{\contentsline {section}{References}{12}}
