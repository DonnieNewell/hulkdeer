\documentclass[11pt]{article}
\usepackage{mdwlist}
\usepackage{indentfirst}
\begin{document}

\section{Stencil Language}

\subsection{Motivation}

In the paper ``Performance Modeling and Automatic Ghost Zone
Optimization for Iterative Stencil Loops on GPUs,'' the authors write:
\begin{quote}
Ghost zones pose a tradeoff between the cost of redundant computation
and the reduction in communication and and synchronization between
PEs.  This tradeoff remains poorly understood.  Despite the ghost
zone's potential benefit, an improper selection of the ghost zone size
may negatively impact overall performance.
\end{quote}
\begin{quote}
In short, the main contributions of this work are a method for
deriving an ISL's performance as a function of its ghost zone, a
gradient descent optimizer for optimizing the ghost zone size, and a
method for the programmer to briefly annotate conventional ISL code to
automate finding and implementing the optimal ghost zone.
\end{quote}

Our work starts exactly where Meng and Skadron's work ends.  Our
contribution is the definition of a {\em stencil language}.  This is a
formal language in which a programmer can describe an ISL computation,
where the description is completely independent of the concept of
ghost zones.  The programmer does not need to calculate the optimal
ghost zone size -- he does not even need to decide whether to use a
ghost zone at all.

We have developed a tool which reads a stencil language file and
outputs CUDA code which executes the ISL calculation.  The CUDA code
calculates the optimal ghost zone size at runtime using the functions
defined by Meng and Skadron, and using data that it collects about the
runtime environment.

In theory, the tool can be extended with multiple back-ends.  Based on
a single source file, it could output code for CUDA or OpenMP or other
environments.  Different environments will have different optimal
ghost zone sizes.  The generated code can always calculate the correct
size for its environment.

\subsection{Syntax}

A stencil language file is a plain text line-oriented file that
contains a set of key-value pairs.  The key and value are separated by
whitespace.  A key is an alphanumeric string.  A value can be:
\begin{itemize}
\item an integer
\item a string of alphanumeric and underscore characters
\item an array of scalars, inside parentheses, separated by commas
\item a block of C code inside of curly braces
\end{itemize}
Comments start with {\tt //} and go to the end of the line.

\subsection{Content}

The following keys are defined:
\begin{itemize}
\item {\bf NumDimensions} -- A stencil may have 1, 2, or 3 dimensions
\item {\bf StencilSize} -- The size of the stencil in each dimension.
  If the stencil size is 1 in the $x$ dimension, then the value of the
  cell at $(x, y)$ may be based on the previous iteration's values of
  the cells in the $x-1$ and $x+1$ coordinates.
\item {\bf DataType} -- The data may be 32 bit or 64 bit integers or
  floating point numbers.  The values are {\tt int}, {\tt int64}, {\tt
    float}, and {\tt double}.  Values are signed unless preceeded by
  {\tt unsigned}.
\item {\bf FunctionName} -- Name of the function that will be exported
  from the generated .cu file.  The first argument to the function,
  {\tt data}, will be a matrix of the specified data type with the
  specified number of dimensions.  As input to the function, {\tt
    data} must contain the initial state of the problem.  It must
  contain valid data in each of the $x \times y \times z$ cells.  As
  output from the function, it will contain the final data.  The next
  $n$ arguments to the function are the input sizes in each dimension.
  The next argument is the number of iterations to run.
\item {\bf ScalarVariables} -- A list of numeric variables that will
  be arguments to the exported function after {\tt data, x, y, z,
    iterations}.  The caller will pass these arguments to the
  function, and then the stencil calculator will be able to use these
  variables (read-only) in its calculations.
\item {\bf CellValue} --A block of C code that will be run for every
  cell in the data set in every iteration.  The code has access to the
  following variables and functions:
\begin{itemize}
\item {\tt x, y, z} -- The coordinates of the current cell in each
  dimension.
\item {\tt iteration} -- The iteration number.  Since iteration 0 is
  given as input, this code will first be called with {\tt iteration}
  = 1.
\item {\tt input\_size} -- a structure with {\tt x}, {\tt y}, and {\tt
  z} fields, containing the values from the {\bf InputSize} field.
\item All variables listed in the {\bf ScalarVariables} field.
\item {\tt get(...)} -- a function that efficiently returns values
  from the stencil from the previous iteration.  The parameters are
  relative to the current cell.  For example, in a two-dimensional
  stencil, the west and east neighbors can be retrieved with {\tt
    get(-1, 0)} and {\tt get(1, 0)}.
\end{itemize}
The block of code returns the new cell value.
\item {\bf EdgeValue} -- A block of C code that returns the cell value
  of cells that are outside the bounds of the input.  This code has
  access to the same variables as the {\bf CellValue} code.  Note that
  at least one of {\tt x}, {\tt y}, or {\tt z} will be out of bounds
  -- it will be either less than zero or greater than or equal to the
  size of that dimension.  This code may not use the {\tt get()}
  function.  Instead, it can access the {\tt value} variable, which
  will contain the value of the nearest cell in bounds from the
  previous iteration.
\end{itemize}

\subsection{Unnamed Data}

For generated .cu file will export two functions.  One will have the
given function name (e.g. {\tt runStencil}), and the other will have
the function name appended with {\tt SetData} (e.g. {\tt
  runStencilSetData}).  The SetData function will take two arguments:
\begin{enumerate}
\item An array of elements of the specified data type
\item The number of elements in the array
\end{enumerate}
If a program calls {\tt runStencilSetData} before it calls {\tt
  runStencil}, then the stencil calculator will have read-only access
to this data.  The {\bf CellValue} code can access the $i$th read-only
data element by calling {\tt read(i)}.

\subsection{Example Source File}

Here is a stencil language description of the ``hotspot'' problem.  This calculates the temperature patterns in a two-dimensional microchip where the current state is a function of the previous state, the edge values, and a two-dimensional read-only ``power usage'' matrix:
\begin{verbatim}
NumDimensions 2
StencilSize (1, 1)
DataType float
FunctionName runHotspot

ScalarVariables (
    float step_div_Cap, float Rx, float Ry, float Rz
}

CellValue {
    float pvalue, value, term1, term2, term3, sum;
    pvalue = read(y * input_size.x + x);
    value = get(0, 0);
    term1 = (get(0, 1) + get(0, -1) - value - value) / Ry;
    term2 = (get(1, 0) + get(-1, 0) - value - value) / Rx;
    term3 = (80.0 - value) / Rz;
    sum = pvalue + term1 + term2 + term3;
    return(value + step_div_Cap * sum);
}

EdgeValue {
    return value;
}
\end{verbatim}

\subsection{Unanswered Questions}

\begin{itemize}
\item The names {\tt get()} and {\tt read()} are awfully generic.
  Should they be replaced by more specific names?
\item Should {\bf DataType} support smaller types?
\item Some stencils may need to run until they reach as particular
  state, as opposed to a given number of iterations.  Should we
  replace {\bf Iterations} with this:
\item {\bf FinishValue} --A block of C code that runs after each
  iteration is completed.  It returns 1 if the calculation is finished
  and zero if the loop should continue.  The code has access to the
  following variables and functions:
\begin{itemize}
\item {\tt iteration} -- The completed iteration number.
\item {\tt input\_size} -- a structure with the {\bf InputSize} values.
\item All variables listed in the {\bf ScalarVariables} field.
\item {\tt get(...)} -- a function that returns the cell value for the
  given global {\tt x}, {\tt y}, and {\tt z} coordinates.  Depending
  on the target environment, this function may copy the entire data
  set from GPU device memory to host memory.  It may be very slow.
  Avoid this whenever possible.
\end{itemize}
\end{itemize}

\end{document}
