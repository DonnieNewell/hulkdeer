\relax 
\citation{li}
\citation{CUDA1}
\citation{CUDA2}
\citation{OpenCL}
\citation{OpenMP}
\citation{pthreads}
\citation{meng}
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{1}}
\citation{li}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces SL System Diagram showing information flow in a typical usage scenario. The SL source is combined by the SL compiler with the appropriate optimized back-end template. The resultant generated C subroutine for the ISL calculation is called by the rest of the user's application code written in C or C++.}}{2}}
\newlabel{fig:SysOrg}{{1}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {2}SL System Organization}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Iterative Stencil Loops: Terms \& Background}{2}}
\citation{meng}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces (a) For a single tile in a 2D matrix, the number of valid calculated values decreases with each additional time interval calculated between synchronization events. After 4 time steps, only the inner most rectangle of $n$ values are valid. (b) Two adjacent tiles shown from the plane of the 2D array with time in the vertical dimension. In the first time step (diagram bottom) there is substantial overlap in the ghost zones in order to have the resultant valid values just abut after 4 time steps (diagram top).}}{3}}
\newlabel{fig:trapezoid}{{2}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces The Hotspot.sl stencil language file. This example shows a 2D stencil calculation where each cell value is based on the values of that cell's immediate neighbors. The read-only data is interpreted as a 2D matrix in row-major order which indicates that some areas of the chip inherently run hotter then other areas.}}{3}}
\newlabel{fig:hotspot}{{3}{3}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Stencil Language Definition}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Syntax}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}Content}{3}}
\citation{CUDA1}
\citation{CUDA2}
\citation{Fermi}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.3}Read Only Data}{4}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Stencil Language Compiler}{4}}
\@writefile{toc}{\contentsline {section}{\numberline {6}Generated CUDA Code}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1}CUDA Architecture Overview}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces NVIDIA GPU Diagram. The CPU control thread launches a kernel with many threads per thread block. Each thread block is assigned to a Multiprocessor (PE) containing 8 scalar processing elements and a local shared memory. The Device Memory is global to all thread blocks and in pre-Fermi GPUs is uncached.}}{5}}
\newlabel{fig:CUDAOrg}{{4}{5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2}SL CUDA Template}{5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3}Pyramid Height Calculation}{5}}
\citation{Mashey}
\@writefile{toc}{\contentsline {section}{\numberline {7}Experimental Results}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.1}GT200 Results}{6}}
\citation{hotspot}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Runtimes for the Pathfinder 1D application vs. PH. The lowest portion of the curves are very flat. Therefore, even though our model did not pick the best PH for any data set size, the performance was within 0.99\% and 2.79\% of optimal.}}{7}}
\newlabel{fig:pathfinderTimes}{{5}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2}\em  ``Pathfinder''}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.3}\em  ``Hotspot''}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Runtimes for the Hotspot 2D stencil application vs. PH. As can be seen, the curve is bowl shape with a noticeable low point at PH 2. The effect is more pronounced with greater data set sizes. Our optimizer picked the correct PH of 2 for all these data sets.}}{7}}
\newlabel{fig:hotspotTimes}{{6}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.4}\em  ``Plate''}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5}\em  ``Cell''}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.6}Model Comparisons}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Runtimes for the Cell 3D stencil application vs. PH. The curve shows that a PH of 3 is a very bad choice. While the values for 1 and 2 are slightly compressed in the graph the optimal PH is in fact 1 for all data sets, as was accurately predicted by our optimizer.}}{8}}
\newlabel{fig:cellTimes}{{7}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces  Runtimes for Hotspot vs. normalized runtimes predicted by the Model for PHs from 1 to 6. While the shape of the model curve does not exactly match the measured runtimes, the model accurately predicts an optimal PH of two. }}{8}}
\newlabel{fig:modelvsactual}{{8}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.7}Comparison to Na\"{i}ve CUDA code}{8}}
\citation{li}
\citation{cm2}
\citation{ypnos}
\citation{kamil}
\citation{AutoTuning}
\@writefile{lot}{\contentsline {table}{\numberline {1}{\ignorespaces  Runtimes for the SL optimized code for the four applications in Section 7, plus two new versions of Plate. Runtimes are also shown for a na\"{i}ve CUDA implementation, along with a comparison relative to SL optimized code. For applications with large amounts of either temporal or spatial locality, the SL generated code far outperforms the na\"{i}ve code. For other applications, the difference is more modest. }}{9}}
\newlabel{fig:GT200Table}{{1}{9}}
\@writefile{lot}{\contentsline {table}{\numberline {2}{\ignorespaces  Data similar to Table\nobreakspace  {}1\hbox {} but now run on the Fermi series GTX-480 GPU card. Note that the increased block size on Fermi results in higher optimal PH for Plate, PlateHalo, and Plate++ due to the larger tile sizes. The inclusion of a cache on Fermi also results in a lower relative improvement of SL optimized code vs na\"{i}ve for applications with large amounts of temporal or spatial locality. }}{9}}
\newlabel{fig:FermiTable}{{2}{9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.8}Fermi Results}{9}}
\@writefile{toc}{\contentsline {section}{\numberline {8}Related Work}{9}}
\citation{Micikevicius}
\citation{volkov}
\citation{openmp2gpu}
\citation{cudalite}
\citation{Ryoo}
\bibstyle{abbrvnat}
\bibdata{PPoPP-report}
\bibcite{cm2}{{1}{1993}{{Brickner et~al.}}{{Brickner, George, Johnsson, and Ruttenberg}}}
\bibcite{OpenMP}{{2}{2007}{{Chapman et~al.}}{{Chapman, Jost, and Pas}}}
\bibcite{AutoTuning}{{3}{2008}{{Datta et~al.}}{{Datta, Murphy, Volkov, Williams, Carter, Oliker, Patterson, Shalf, and Yelick}}}
\bibcite{kamil}{{4}{2006}{{Kamil et~al.}}{{Kamil, Datta, Williams, Oliker, Shalf, and Yelick}}}
\bibcite{openmp2gpu}{{5}{2009}{{Lee et~al.}}{{Lee, Min, and Eigenmann}}}
\bibcite{li}{{6}{2004}{{Li and Song}}{{}}}
\bibcite{CUDA1}{{7}{2008}{{Lindholm et~al.}}{{Lindholm, Nickolls, Oberman, and Montrym}}}
\bibcite{Mashey}{{8}{2004}{{Mashey}}{{}}}
\bibcite{meng}{{9}{2009}{{Meng and Skadron}}{{}}}
\bibcite{Micikevicius}{{10}{2009}{{Micikevicius}}{{}}}
\bibcite{pthreads}{{11}{1996}{{Nichols et~al.}}{{Nichols, Buttlar, and Farrell}}}
\bibcite{Fermi}{{12}{2010}{{Nickolls and Dally}}{{}}}
\bibcite{CUDA2}{{13}{2008}{{Nickolls et~al.}}{{Nickolls, Buck, Garland, and Skadron}}}
\bibcite{ypnos}{{14}{2010}{{Orchard et~al.}}{{Orchard, Bolingbroke, and Mycroft}}}
\bibcite{Ryoo}{{15}{2008}{{Ryoo et~al.}}{{Ryoo, Rodrigues, Baghsorkhi, Stone, Kirk, and Hwu}}}
\bibcite{hotspot}{{16}{2004}{{Skadron et~al.}}{{Skadron, Stan, Sankaranarayanan, Huang, Velusamy, and Tarjan}}}
\bibcite{OpenCL}{{17}{2010}{{Stone et~al.}}{{Stone, Gohara, and Shi}}}
\bibcite{cudalite}{{18}{2008}{{Ueng et~al.}}{{Ueng, Lathara, Baghsorkhi, and Hwu}}}
\bibcite{volkov}{{19}{2008}{{Volkov, Vasily and Demmel, James}}{{}}}
\@writefile{toc}{\contentsline {section}{\numberline {9}Conclusions and Future Directions}{10}}
\newlabel{sigplanconf@finalpage}{{9}{10}}
